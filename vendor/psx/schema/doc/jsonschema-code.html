<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>JSON Schema Code: JSON Schema rules to simplify code generation</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.2" rel="Chapter" title="2 Conventions and Terminology">
<link href="#rfc.section.3" rel="Chapter" title="3 Overview">
<link href="#rfc.section.4" rel="Chapter" title="4 Restriction rules">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Definition">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Combination">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Reference">
<link href="#rfc.section.5" rel="Chapter" title="5 Not supported keywords">
<link href="#rfc.section.6" rel="Chapter" title="6 Validation keywords">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Definition keywords">
<link href="#rfc.section.6.1.1" rel="Chapter" title="6.1.1 Common keywords">
<link href="#rfc.section.6.1.2" rel="Chapter" title="6.1.2 Object keywords">
<link href="#rfc.section.6.1.3" rel="Chapter" title="6.1.3 Array keywords">
<link href="#rfc.section.6.1.4" rel="Chapter" title="6.1.4 Scalar keywords">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Combination keywords">
<link href="#rfc.section.6.2.1" rel="Chapter" title="6.2.1 allOf">
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Reference keywords">
<link href="#rfc.section.7" rel="Chapter" title="7 Schema">
<link href="#rfc.references" rel="Chapter" title="8 References">
<link href="#rfc.references.1" rel="Chapter" title="8.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="8.2 Informative References">
<link href="#rfc.appendix.A" rel="Chapter" title="A Acknowledgments">
<link href="#rfc.appendix.B" rel="Chapter" title="B ChangeLog">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.8.0 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Kappestein, C., Ed." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-kappestein-json-schema-code-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2017-9-17" />
  <meta name="dct.abstract" content="JSON Schema provides many ways to describe a JSON structure. The price of this flexibility is that it is difficult for code generators to understand a JSON Schema. This specification restricts the JSON Schema keywords to a subset with a deterministic behaviour.  " />
  <meta name="description" content="JSON Schema provides many ways to describe a JSON structure. The price of this flexibility is that it is difficult for code generators to understand a JSON Schema. This specification restricts the JSON Schema keywords to a subset with a deterministic behaviour.  " />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Internet Engineering Task Force</td>
<td class="right">C. Kappestein, Ed.</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">September 17, 2017</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right"></td>
</tr>
<tr>
<td class="left">Expires: March 21, 2018</td>
<td class="right"></td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">JSON Schema Code: JSON Schema rules to simplify code generation<br />
  <span class="filename">draft-kappestein-json-schema-code-00</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>JSON Schema provides many ways to describe a JSON structure. The price of this flexibility is that it is difficult for code generators to understand a JSON Schema. This specification restricts the JSON Schema keywords to a subset with a deterministic behaviour.  </p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on March 21, 2018.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2017 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>2.   <a href="#rfc.section.2">Conventions and Terminology</a>
</li>
<li>3.   <a href="#rfc.section.3">Overview</a>
</li>
<li>4.   <a href="#rfc.section.4">Restriction rules</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Definition</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Combination</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">Reference</a>
</li>
</ul><li>5.   <a href="#rfc.section.5">Not supported keywords</a>
</li>
<li>6.   <a href="#rfc.section.6">Validation keywords</a>
</li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Definition keywords</a>
</li>
<ul><li>6.1.1.   <a href="#rfc.section.6.1.1">Common keywords</a>
</li>
<li>6.1.2.   <a href="#rfc.section.6.1.2">Object keywords</a>
</li>
<li>6.1.3.   <a href="#rfc.section.6.1.3">Array keywords</a>
</li>
<li>6.1.4.   <a href="#rfc.section.6.1.4">Scalar keywords</a>
</li>
</ul><li>6.2.   <a href="#rfc.section.6.2">Combination keywords</a>
</li>
<ul><li>6.2.1.   <a href="#rfc.section.6.2.1">allOf</a>
</li>
</ul><li>6.3.   <a href="#rfc.section.6.3">Reference keywords</a>
</li>
</ul><li>7.   <a href="#rfc.section.7">Schema</a>
</li>
<li>8.   <a href="#rfc.references">References</a>
</li>
<ul><li>8.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>8.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Acknowledgments</a>
</li>
<li>Appendix B.   <a href="#rfc.appendix.B">ChangeLog</a>
</li>
<li><a href="#rfc.authors">Author's Address</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> Introduction</h1>
<p id="rfc.section.1.p.1">This vocabulary restricts the JSON Schema Validation keywords to a clear subset which removes ambiguities and inherent invalid schemas.  </p>
<p id="rfc.section.1.p.2">If a JSON Schema follows these rules it is easier for processors and code generators to consume. This leads to better results and maintainability of a schema.  </p>
<p id="rfc.section.1.p.3">This specification should be seen as extension to the JSON Schema draft-wright-json-schema-validation-00 specification.  </p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> Conventions and Terminology</h1>
<p id="rfc.section.2.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119" class="xref">RFC 2119</a>.  </p>
<p id="rfc.section.2.p.2">The terms "JSON", "JSON text", "JSON value", "member", "element", "object", "array", "number", "string", "boolean", "true", "false", and "null" in this document are to be interpreted as defined in <a href="#RFC7159" class="xref">RFC 7159</a>.  </p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> Overview</h1>
<p id="rfc.section.3.p.1">This document describes the JSON Schema restriction rules and all available validation keywords and their corresponding behaviour. It contains also a JSON Schema to validate whether a JSON Schema complies to these rules.  </p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> Restriction rules</h1>
<p id="rfc.section.4.p.1">In the JSON Schema core specification all keywords are optional and are applied in context with the actual data. The idea of this specification is to build schemas which have a distinct meaning independent of the actual data and which can be used to generate different representations i.e. model classes of a specific programming language. Because of this we must restrict existing keywords and must make specific keywords mandatory depending on the context.  </p>
<p id="rfc.section.4.p.2">In this specification every schema is exactly assigned to a specific type of schema: Definition, Combination or Reference. The distinction is made based on the used keywords.  </p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> Definition</h1>
<p id="rfc.section.4.1.p.1">A definition schema is a schema which describes a concrete type.  It must follow the rules: </p>
<p></p>

<ul>
<li>Every schema MUST have a "type" keyword. The type must be one of: "object", "array", "boolean", "number", "integer" or "string" </li>
<li>Every schema of type "object" MUST have a "title" keyword. This is required so that code generators can build class names or other identifiers based on this title.  </li>
<li>Every schema of type "object" is either a struct (MUST have a "properties" keyword) or a map (MUST have a "additionalProperties" keyword).  </li>
<li>Every schema of type "array" MUST have an "items" keyword.  The items can only contain definition ("object", "boolean", "number", "string") or reference schemas.  </li>
<li>It is not possible to mix multiple constraints i.e. a schema of type "string" can only use string specific validation keywords i.e. "minLength".  </li>
</ul>

<p> </p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> Combination</h1>
<p id="rfc.section.4.2.p.1">A combination schema combines multiple schemas in a specific way.  It must follow the rules: </p>
<p></p>

<ul>
<li>Every schema MUST have one of the following keywords: "allOf", "anyOf" or "oneOf".  </li>
<li>The value must be an array which can contain only definition or reference schemas. These schemas MUST be of type "object".  </li>
</ul>

<p> </p>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> Reference</h1>
<p id="rfc.section.4.3.p.1">A reference schema makes a reference to another schema.  It must follow the rules: </p>
<p></p>

<ul>
<li>Every schema MUST have the keyword "$ref".  </li>
<li>A reference schema MUST follow the same rules as a definition schema. That means i.e. if a reference is used inside the "allOf" keyword it MUST only reference object types.  </li>
</ul>

<p> </p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> Not supported keywords</h1>
<p id="rfc.section.5.p.1">The following keywords are not supported. Not supported means that they have no special meaning in this specification and code generators should ignore those keywords.  </p>
<p></p>

<ul>
<li>The "patternProperties" keyword is not supported.  </li>
<li>The "type" keyword MUST be a string. The array notation is not supported.  </li>
<li>The "null" type is not supported.  </li>
<li>The "not" keyword is not supported.  </li>
<li>The "dependencies" keyword is not supported.  </li>
<li>The "additionalItems" keyword is not supported.  </li>
</ul>

<p> </p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> Validation keywords</h1>
<p id="rfc.section.6.p.1">This specification restricts the usage of the validation keywords.  Which keywords are allowed depends on the schema type.  </p>
<p id="rfc.section.6.p.2">The following chapter lists all available keywords and describes the concrete behaviour.  </p>
<p id="rfc.section.6.p.3">If not otherwise noted the behaviour of a keyword is identical to the <a href="#json-schema-validation" class="xref">JSON Schema validation</a> specification.  </p>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> Definition keywords</h1>
<p id="rfc.section.6.1.p.1">The following keywords can be used to describe a definition schema.  </p>
<h1 id="rfc.section.6.1.1">
<a href="#rfc.section.6.1.1">6.1.1.</a> Common keywords</h1>
<p id="rfc.section.6.1.1.p.1">The following keywords can be used in any definition schema: </p>
<p></p>

<ul>
<li>title</li>
<li>description</li>
<li>type</li>
</ul>

<p> </p>
<h1 id="rfc.section.6.1.1.1">
<a href="#rfc.section.6.1.1.1">6.1.1.1.</a> title</h1>
<p id="rfc.section.6.1.1.1.p.1">The value of this keyword MUST be a string. Should only contain the characters "A-Z", "a-z" and "_".  </p>
<p id="rfc.section.6.1.1.1.p.2">Should be a distinct word which represents this schema, may be used to generate i.e. class names or other identifiers.  </p>
<p id="rfc.section.6.1.1.1.p.3">Schemas with the same title should represent the same constraints since a processor could merge multiple schemas and thus remove duplicate schemas.  </p>
<h1 id="rfc.section.6.1.1.2">
<a href="#rfc.section.6.1.1.2">6.1.1.2.</a> description</h1>
<p id="rfc.section.6.1.1.2.p.1">The value of this keyword MUST be a string.  </p>
<p id="rfc.section.6.1.1.2.p.2">Contains a general description of this property. Should only contain simple text and no line breaks since the description is may be used in code comments or other character sensitive environments.  </p>
<h1 id="rfc.section.6.1.1.3">
<a href="#rfc.section.6.1.1.3">6.1.1.3.</a> type</h1>
<p id="rfc.section.6.1.1.3.p.1">The value of this keyword MUST be a string.  </p>
<p id="rfc.section.6.1.1.3.p.2">String values MUST be one of the six primitive types ("boolean", "object", "array", "number", or "string"), or "integer" which matches any number with a zero fractional part.  </p>
<h1 id="rfc.section.6.1.2">
<a href="#rfc.section.6.1.2">6.1.2.</a> Object keywords</h1>
<p id="rfc.section.6.1.2.p.1">If a schema has a "type" keyword which is "object" the following validation keywords can be used: </p>
<p></p>

<ul>
<li><a href="https://tools.ietf.org/html/draft-wright-json-schema-validation-00#section-5.15">required</a></li>
<li><a href="https://tools.ietf.org/html/draft-wright-json-schema-validation-00#section-5.16">properties</a></li>
<li><a href="https://tools.ietf.org/html/draft-wright-json-schema-validation-00#section-5.18">additionalProperties</a></li>
<li><a href="https://tools.ietf.org/html/draft-wright-json-schema-validation-00#section-5.13">maxProperties</a></li>
<li><a href="https://tools.ietf.org/html/draft-wright-json-schema-validation-00#section-5.14">minProperties</a></li>
</ul>

<p> </p>
<p id="rfc.section.6.1.2.p.3">An object must be either a struct or map type. A struct object contains a set of fixed properties and a map object contains variable key value entries.  </p>
<p id="rfc.section.6.1.2.p.4">Each object type MUST have also a "title" keyword. The title may be used by a generator to determine a class name for a schema.  </p>
<h1 id="rfc.section.6.1.2.1">
<a href="#rfc.section.6.1.2.1">6.1.2.1.</a> Struct keywords</h1>
<p id="rfc.section.6.1.2.1.p.1">A struct is an object which MUST have at least a "type", "title" and "properties" keyword.  </p>
<pre>
                                
{
    "title": "Person",
    "type": "object",
    "properties": {
        "forname": {
            "type": "string"
        },
        "lastname": {
            "type": "string"
        }
    }
}

                            </pre>
<h1 id="rfc.section.6.1.2.2">
<a href="#rfc.section.6.1.2.2">6.1.2.2.</a> Map keywords</h1>
<p id="rfc.section.6.1.2.2.p.1">A map is an object which MUST have at least a "type", "title" and "additionalProperties" keyword.  </p>
<pre>
                                
{
    "title": "Config",
    "type": "object",
    "additionalProperties": {
        "type": "string"
    }
}

                            </pre>
<h1 id="rfc.section.6.1.3">
<a href="#rfc.section.6.1.3">6.1.3.</a> Array keywords</h1>
<p id="rfc.section.6.1.3.p.1">If a schema has a "type" keyword which is "array" the following validation keywords can be used: </p>
<p></p>

<ul>
<li><a href="https://tools.ietf.org/html/draft-wright-json-schema-validation-00#section-5.9">items</a></li>
<li><a href="https://tools.ietf.org/html/draft-wright-json-schema-validation-00#section-5.10">maxItems</a></li>
<li><a href="https://tools.ietf.org/html/draft-wright-json-schema-validation-00#section-5.11">minItems</a></li>
<li><a href="https://tools.ietf.org/html/draft-wright-json-schema-validation-00#section-5.12">uniqueItems</a></li>
</ul>

<p> </p>
<h1 id="rfc.section.6.1.4">
<a href="#rfc.section.6.1.4">6.1.4.</a> Scalar keywords</h1>
<p id="rfc.section.6.1.4.p.1">If a schema has a "type" keyword which is either "boolean", "number" or "string" the following validation keywords can be used: </p>
<p></p>

<ul>
<li><a href="https://tools.ietf.org/html/draft-wright-json-schema-validation-00#section-7">format</a></li>
<li><a href="https://tools.ietf.org/html/draft-wright-json-schema-validation-00#section-5.20">enum</a></li>
</ul>

<p> </p>
<h1 id="rfc.section.6.1.4.1">
<a href="#rfc.section.6.1.4.1">6.1.4.1.</a> format</h1>
<p id="rfc.section.6.1.4.1.p.1">In the context of code generation the "format" keyword gives a hint about the concrete data type of a property. While the JSON schema validation specification defines many formats this specification supports only the formats which are usable in the context of code generation. I.e. if the format is "date-time" a code generator could utilize the standard date class of the target programming language.  A code generator should consider the following formats: </p>
<p></p>

<ul>
<li>int32 (signed 32 bits)</li>
<li>int64 (signed 64 bits)</li>
<li>float</li>
<li>double</li>
<li>byte (base64 encoded characters)</li>
<li>binary (any sequence of octets)</li>
<li>date (as defined by full-date <a href="#RFC3339" class="xref">RFC 3339</a>)</li>
<li>date-time (as defined by date-time <a href="#RFC3339" class="xref">RFC 3339</a>)</li>
</ul>

<p> </p>
<h1 id="rfc.section.6.1.4.2">
<a href="#rfc.section.6.1.4.2">6.1.4.2.</a> Boolean keywords</h1>
<p id="rfc.section.6.1.4.2.p.1">If a schema has a "type" keyword which is "boolean" no validation keywords are available.  </p>
<h1 id="rfc.section.6.1.4.3">
<a href="#rfc.section.6.1.4.3">6.1.4.3.</a> Number keywords</h1>
<p id="rfc.section.6.1.4.3.p.1">If a schema has a "type" keyword which is either "number" or "integer" the following validation keywords can be used: </p>
<p></p>

<ul>
<li><a href="https://tools.ietf.org/html/draft-wright-json-schema-validation-00#section-5.1">multipleOf</a></li>
<li><a href="https://tools.ietf.org/html/draft-wright-json-schema-validation-00#section-5.2">maximum</a></li>
<li><a href="https://tools.ietf.org/html/draft-wright-json-schema-validation-00#section-5.3">exclusiveMaximum</a></li>
<li><a href="https://tools.ietf.org/html/draft-wright-json-schema-validation-00#section-5.4">minimum</a></li>
<li><a href="https://tools.ietf.org/html/draft-wright-json-schema-validation-00#section-5.5">exclusiveMinimum</a></li>
</ul>

<p> </p>
<h1 id="rfc.section.6.1.4.4">
<a href="#rfc.section.6.1.4.4">6.1.4.4.</a> String keywords</h1>
<p id="rfc.section.6.1.4.4.p.1">If a schema has a "type" keyword which is "string" the following validation keywords can be used: </p>
<p></p>

<ul>
<li><a href="https://tools.ietf.org/html/draft-wright-json-schema-validation-00#section-5.6">maxLength</a></li>
<li><a href="https://tools.ietf.org/html/draft-wright-json-schema-validation-00#section-5.7">minLength</a></li>
<li><a href="https://tools.ietf.org/html/draft-wright-json-schema-validation-00#section-5.8">pattern</a></li>
</ul>

<p> </p>
<h1 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> Combination keywords</h1>
<p id="rfc.section.6.2.p.1">The following keywords can be used to describe a combination schema: </p>
<p></p>

<ul>
<li><a href="https://tools.ietf.org/html/draft-wright-json-schema-validation-00#section-5.22">allOf</a></li>
<li><a href="https://tools.ietf.org/html/draft-wright-json-schema-validation-00#section-5.23">anyOf</a></li>
<li><a href="https://tools.ietf.org/html/draft-wright-json-schema-validation-00#section-5.24">oneOf</a></li>
</ul>

<p> </p>
<h1 id="rfc.section.6.2.1">
<a href="#rfc.section.6.2.1">6.2.1.</a> allOf</h1>
<p id="rfc.section.6.2.1.p.1">The all of array should be used to express inheritance. The array should list the most generic definition at the first position of the array and the most specific definition at the bottom.  </p>
<p id="rfc.section.6.2.1.p.2">Through this code generators could implement inheritance alongside the array.  </p>
<p id="rfc.section.6.2.1.p.3">Also it is possible to aggregate all schemas into a single schema. Since the all of array can only contain schemas of type "object" it is clear that the result is also always an schema of type "object".  </p>
<pre>
                            
{
    "allOf": [{
        "$ref": "#/definitions/person"
    }, {
        "title": "teacher",
        "type": "object",
        "properties": {
            "classroom": {
                "type": "string"
            }
        }
    }]
}

                        </pre>
<h1 id="rfc.section.6.3">
<a href="#rfc.section.6.3">6.3.</a> Reference keywords</h1>
<p id="rfc.section.6.3.p.1">The following keywords can be used to describe a reference schema: </p>
<p></p>

<ul><li><a href="https://tools.ietf.org/html/draft-wright-json-schema-00#section-7">$ref</a></li></ul>

<p> </p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> Schema</h1>
<p id="rfc.section.7.p.1">The following JSON Schema can be used to validate whether a JSON Schema follows these rules.  </p>
<pre>
                    
{
  "description": "A strict JsonSchema meta schema to simplify code generation",
  "oneOf": [{
    "$ref": "#/definitions/definition"
  }, {
    "$ref": "#/definitions/combination"
  }, {
    "$ref": "#/definitions/reference"
  }],
  "definitions": {
    "common": {
      "description": "Common properties which can be used in any schema",
      "title": "common",
      "type": "object",
      "properties": {
        "title": {
          "type": "string",
          "description": "Distinct word which represents this property, may be used to generate i.e. class names or other identifier"
        },
        "description": {
          "type": "string",
          "description": "General description of this property"
        },
        "type": {
          "type": "string",
          "description": "JSON type of the property",
          "enum": ["object", "array", "boolean", "integer", "number", "string"]
        },
        "nullable": {
          "type": "boolean",
          "description": "Whether it is possible to use a null value on this property",
          "default": false
        },
        "deprecated": {
          "type": "boolean",
          "description": "Whether this property is deprecated",
          "default": false
        }
      }
    },
    "commonScalar": {
      "description": "Properties for scalar values",
      "allOf": [{
        "$ref": "#/definitions/common"
      }, {
        "title": "scalar",
        "type": "object",
        "properties": {
          "format": {
            "type": "string",
            "description": "Describes the specific format of this type i.e. date-time or int64"
          },
          "enum": {
            "type": "array",
            "description": "A list of possible enumeration values",
            "items": {
              "oneOf": [{
                "type": "string"
              },{
                "type": "number"
              }]
            },
            "minItems": 1
          }
        }
      }]
    },
    "commonContainer": {
      "description": "Properties for object values",
      "allOf": [{
        "$ref": "#/definitions/common"
      }, {
        "title": "container",
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "description": "Distinct word which represents this property, may be used to generate i.e. class names or other identifier"
          },
          "type": {
            "type": "string",
            "enum": ["object"]
          },
          "required": { "$ref": "#/definitions/stringArray" }
        },
        "required": ["title", "type"]
      }]
    },
    "object": {
      "description": "An object represents either a struct or map",
      "oneOf": [{
        "$ref": "#/definitions/objectStruct"
      }, {
        "$ref": "#/definitions/objectMap"
      }]
    },
    "objectStruct": {
      "description": "A struct contains a fix set of defined properties",
      "allOf": [{
        "$ref": "#/definitions/commonContainer"
      }, {
        "title": "struct",
        "type": "object",
        "properties": {
          "properties": {
            "type": "object",
            "additionalProperties": { "$ref": "#" }
          }
        },
        "required": ["properties"]
      }]
    },
    "objectMap": {
      "description": "A map contains variable key value entries",
      "allOf": [{
        "$ref": "#/definitions/commonContainer"
      }, {
        "title": "map",
        "type": "object",
        "properties": {
          "additionalProperties": { "$ref": "#" },
          "maxProperties": { "$ref": "#/definitions/positiveInteger" },
          "minProperties": { "$ref": "#/definitions/positiveInteger" }
        },
        "required": ["additionalProperties"]
      }]
    },
    "array": {
      "description": "An array contains an ordered list of variable values",
      "allOf": [{
        "$ref": "#/definitions/common"
      }, {
        "title": "array",
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": ["array"]
          },
          "items": {
            "$ref": "#/definitions/arrayItem"
          },
          "maxItems": { "$ref": "#/definitions/positiveInteger" },
          "minItems": { "$ref": "#/definitions/positiveInteger" },
          "uniqueItems": { 
            "type": "boolean"
          }
        },
        "required": ["type", "items"]
      }]
    },
    "boolean": {
      "description": "Represents a boolean value",
      "allOf": [{
        "$ref": "#/definitions/commonScalar"
      }, {
        "title": "boolean",
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": ["boolean"]
          }
        },
        "required": ["type"]
      }]
    },
    "number": {
      "description": "Represents a number value which contains also integer",
      "allOf": [{
        "$ref": "#/definitions/commonScalar"
      }, {
        "title": "number",
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": ["number", "integer"]
          },
          "multipleOf": {
            "type": "number",
            "minimum": 0,
            "exclusiveMinimum": true
          },
          "maximum": {
            "type": "number"
          },
          "exclusiveMaximum": {
            "type": "boolean",
            "default": false
          },
          "minimum": {
            "type": "number"
          },
          "exclusiveMinimum": {
            "type": "boolean",
            "default": false
          }
        },
        "required": ["type"]
      }]
    },
    "string": {
      "description": "Represents a string value",
      "allOf": [{
        "$ref": "#/definitions/commonScalar"
      }, {
        "title": "string",
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": ["string"]
          },
          "maxLength": { "$ref": "#/definitions/positiveInteger" },
          "minLength": { "$ref": "#/definitions/positiveInteger" },
          "pattern": {
            "type": "string",
            "format": "regex"
          }
        },
        "required": ["type"]
      }]
    },
    "allOf": {
      "description": "Combination keyword to validate all containing schemas",
      "allOf": [{
        "$ref": "#/definitions/common"
      }, {
        "title": "allOf",
        "type": "object",
        "properties": {
          "allOf": { "$ref": "#/definitions/of" }
        },
        "required": ["allOf"]
      }]
    },
    "anyOf": {
      "description": "Combination keyword to validate any containing schemas",
      "allOf": [{
        "$ref": "#/definitions/common"
      }, {
        "title": "anyOf",
        "type": "object",
        "properties": {
          "anyOf": { "$ref": "#/definitions/of" }
        },
        "required": ["anyOf"]
      }]
    },
    "oneOf": {
      "description": "Combination keyword to validate exactly one containing schemas",
      "allOf": [{
        "$ref": "#/definitions/common"
      }, {
        "title": "oneOf",
        "type": "object",
        "properties": {
          "discriminator": { "$ref": "#/definitions/discriminator" },
          "oneOf": { "$ref": "#/definitions/of" }
        },
        "required": ["oneOf"]
      }]
    },
    "discriminator": {
      "description": "Adds support for polymorphism. The discriminator is an object name that is used to differentiate between other schemas which may satisfy the payload description",
      "title": "discriminator",
      "type": "object",
      "properties": {
        "propertyName": {
          "type": "string",
          "description": "The name of the property in the payload that will hold the discriminator value"
        },
        "mapping": {
          "type": "object",
          "description": "An object to hold mappings between payload values and schema names or references",
          "additionalProperties": {
            "type": "string"
          }
        }
      },
      "required": ["propertyName"]
    },
    "positiveInteger": {
      "description": "Positive integer value",
      "type": "integer",
      "minimum": 0
    },
    "stringArray": {
      "description": "Array string values",
      "type": "array",
      "items": { "type": "string" },
      "minItems": 1
    },
    "of": {
      "description": "Combination values",
      "type": "array",
      "items": {
        "$ref": "#/definitions/objectOrReference"
      }
    },
    "objectOrReference": {
      "description": "Object or reference value",
      "oneOf": [{
        "$ref": "#/definitions/object"
      }, {
        "$ref": "#/definitions/reference"
      }]
    },
    "arrayItem": {
      "description": "Allowed values of an array item",
      "oneOf": [{
        "$ref": "#/definitions/object"
      }, {
        "$ref": "#/definitions/boolean"
      }, {
        "$ref": "#/definitions/number"
      }, {
        "$ref": "#/definitions/string"
      }, {
        "$ref": "#/definitions/reference"
      }]
    },
    "definition": {
      "description": "Represents a concrete type definition",
      "oneOf": [{
        "$ref": "#/definitions/object"
      }, {
        "$ref": "#/definitions/array"
      }, {
        "$ref": "#/definitions/boolean"
      }, {
        "$ref": "#/definitions/number"
      }, {
        "$ref": "#/definitions/string"
      }]
    },
    "combination": {
      "description": "Represents a combination of schemas",
      "oneOf": [{
        "$ref": "#/definitions/allOf"
      }, {
        "$ref": "#/definitions/anyOf"
      }, {
        "$ref": "#/definitions/oneOf"
      }]
    },
    "reference": {
      "description": "Represents a reference to another schema",
      "title": "reference",
      "type": "object",
      "properties": {
        "$ref": {
          "type": "string"
        }
      },
      "required": ["$ref"]
    }
  }
}

                </pre>
<h1 id="rfc.references">
<a href="#rfc.references">8.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">8.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3339">[RFC3339]</b></td>
<td class="top">
<a>Klyne, G.</a> and <a>C. Newman</a>, "<a href="https://tools.ietf.org/html/rfc3339">Date and Time on the Internet: Timestamps</a>", RFC 3339, DOI 10.17487/RFC3339, July 2002.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3986">[RFC3986]</b></td>
<td class="top">
<a>Berners-Lee, T.</a>, <a>Fielding, R.</a> and <a>L. Masinter</a>, "<a href="https://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6901">[RFC6901]</b></td>
<td class="top">
<a>Bryan, P.</a>, <a>Zyp, K.</a> and <a>M. Nottingham</a>, "<a href="https://tools.ietf.org/html/rfc6901">JavaScript Object Notation (JSON) Pointer</a>", RFC 6901, DOI 10.17487/RFC6901, April 2013.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7159">[RFC7159]</b></td>
<td class="top">
<a>Bray, T.</a>, "<a href="https://tools.ietf.org/html/rfc7159">The JavaScript Object Notation (JSON) Data Interchange Format</a>", RFC 7159, DOI 10.17487/RFC7159, March 2014.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">8.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="json-schema-validation">[json-schema-validation]</b></td>
<td class="top">
<a>Wright, A.</a> and <a>G. Luff</a>, "<a href="https://tools.ietf.org/html/draft-wright-json-schema-validation-00">JSON Schema Validation: A Vocabulary for Structural Validation of JSON</a>", Internet-Draft draft-wright-json-schema-validation-00, October 2016.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7231">[RFC7231]</b></td>
<td class="top">
<a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="https://tools.ietf.org/html/rfc7231">Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</a>", RFC 7231, DOI 10.17487/RFC7231, June 2014.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> Acknowledgments</h1>
<p id="rfc.section.A.p.1">Thanks to the JSON Schema and OpenAPI team and contributors.  </p>
<h1 id="rfc.appendix.B">
<a href="#rfc.appendix.B">Appendix B.</a> ChangeLog</h1>
<p><a id="CREF1" class="info">[CREF1]<span class="info">This section to be removed before leaving Internet-Draft status.</span></a> </p>
<p></p>

<dl>
<dt>draft-kappestein-json-schema-code-00</dt>
<dd style="margin-left: 8">
<ul><li>Initial creation</li></ul>
<p> </p>
</dd>
</dl>

<p> </p>
<h1 id="rfc.authors"><a href="#rfc.authors">Author's Address</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Christoph Kappestein</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Kappestein</span>
	  </span>
	</span>
	<span class="org vcardline"></span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:christoph.kappestein@gmail.com">christoph.kappestein@gmail.com</a></span>

  </address>
</div>

</body>
</html>
